## 1. Описание алгоритмов

### 1.1. Пошаговый алгоритм
Базируется на уравнении прямой **y = kx + b**. Основная идея заключается в вычислении координаты **y** для каждого целочисленного шага **x** (или наоборот, если прямая имеет наклон > 45 градусов).
*   **Принцип:** На каждом шаге выполняется умножение коэффициента наклона **k** на текущий **x** и прибавление смещения **b**.
*   **Особенность:** Результат вычислений — вещественное число, поэтому для получения экранной координаты необходимо использовать функцию округления (round). Это делает алгоритм вычислительно дорогим из-за операций с плавающей точкой.

### 1.2. Алгоритм ЦДА (Цифровой Дифференциальный Анализатор)
Является модификацией пошагового алгоритма. Вместо вычисления уравнения прямой "с нуля" на каждом шаге, используются приращения (инкременты).
*   **Принцип:** Рассчитываются шаги изменения координат: **dx_inc = dx / L** и **dy_inc = dy / L**, где **L** — количество шагов (максимальная проекция отрезка). Новая точка получается путем прибавления этих значений к предыдущим.
*   **Особенность:** Устраняется тяжелая операция умножения внутри цикла, но вычисления по-прежнему ведутся в вещественных числах, требуя округления в конце. Накапливается погрешность вычислений на длинных отрезках.

### 1.3. Алгоритм Брезенхема (Отрезок)
Наиболее эффективный растровый алгоритм, работающий исключительно с **целыми числами**.
*   **Принцип:** Алгоритм отслеживает "ошибку" (отклонение идеальной прямой от сетки пикселей). На каждом шаге принимается решение: остаться на той же ординате или сдвинуться на шаг вверх, в зависимости от знака переменной ошибки.
*   **Особенность:** Используются только операции сложения, вычитания и битового сдвига (умножение на 2). Деление и вещественная арифметика отсутствуют, что обеспечивает максимальную скорость работы.

### 1.4. Алгоритм Брезенхема (Окружность)
Позволяет построить окружность без использования тригонометрии и извлечения квадратных корней.
*   **Принцип:** Используется свойство симметрии окружности: вычисляется только один октант (1/8 часть), а остальные точки получаются зеркальным отражением. Выбор следующего пикселя (горизонтальный или диагональный шаг) определяется знаком управляющей переменной (расстояния от центра пикселя до идеальной окружности).
*   **Особенность:** Также работает только в целочисленной арифметике.

---

## 2. Сопроводительные вычисления (Итерации)

**Задача:** Растеризация отрезка с координатами **(0, 0) — (4, 2)**.
Параметры: **dx = 4**, **dy = 2**.

### Таблица 1. Пошаговый алгоритм
k = 0.5, b = 0. Уравнение: **y = 0.5 * x**.

| Шаг (x) | Вычисление y | Округление | Пиксель |
| :--- | :--- | :--- | :--- |
| 0 | 0.5 * 0 = 0 | 0 | **(0, 0)** |
| 1 | 0.5 * 1 = 0.5 | 1 | **(1, 1)** |
| 2 | 0.5 * 2 = 1.0 | 1 | **(2, 1)** |
| 3 | 0.5 * 3 = 1.5 | 2 | **(3, 2)** |
| 4 | 0.5 * 4 = 2.0 | 2 | **(4, 2)** |

### Таблица 2. Алгоритм ЦДА
L = 4. Приращения: **inc_x = 1**, **inc_y = 0.5**.

| Шаг | Текущий x | Текущий y | Округление (Пиксель) |
| :--- | :--- | :--- | :--- |
| 0 | 0.0 | 0.0 | **(0, 0)** |
| 1 | 1.0 | 0.5 | **(1, 1)** |
| 2 | 2.0 | 1.0 | **(2, 1)** |
| 3 | 3.0 | 1.5 | **(3, 2)** |
| 4 | 4.0 | 2.0 | **(4, 2)** |

### Таблица 3. Алгоритм Брезенхема (Отрезок)
Начальная ошибка **E = 2*dy - dx** = 2*2 - 4 = **0**.
Правила:
*   Если **E >= 0**: делаем шаг по y, затем **E = E - 2*dx + 2*dy** (т.е. E - 4).
*   Если **E < 0**: y не меняем, затем **E = E + 2*dy** (т.е. E + 4).

| x | y | Ошибка E (перед шагом) | Решение | Новое E | Пиксель |
| :--- | :--- | :--- | :--- | :--- | :--- |
| 0 | 0 | 0 | E >= 0 -> y+1 | 0 - 4 = -4 | **(0, 0)** |
| 1 | 1 | -4 | E < 0 -> y | -4 + 4 = 0 | **(1, 1)** |
| 2 | 1 | 0 | E >= 0 -> y+1 | 0 - 4 = -4 | **(2, 1)** |
| 3 | 2 | -4 | E < 0 -> y | -4 + 4 = 0 | **(3, 2)** |
| 4 | 2 | - | - | - | **(4, 2)** |

---

## 3. Выводы

На основе проделанной работы и сравнения алгоритмов можно сделать следующие выводы:

1.  **Производительность:**
    *   **Алгоритм Брезенхема** является наиболее быстрым и предпочтительным для аппаратной и программной реализации. Отсутствие операций деления и работы с вещественными типами данных (float) позволяет выполнять его за минимальное количество тактов процессора.
    *   **Пошаговый алгоритм** является самым медленным из-за необходимости выполнения умножения и вызова «тяжелой» функции округления на каждой итерации.

2.  **Точность и стабильность:**
    *   Целочисленные алгоритмы (Брезенхема) лишены проблем накопления ошибки округления, свойственных методам ЦДА и Пошаговому. Это гарантирует, что даже очень длинные линии будут нарисованы корректно, конечная точка всегда совпадет с расчетной.

3.  **Сложность реализации:**
    *   Пошаговый метод и ЦДА интуитивно понятнее, так как следуют напрямую из аналитической геометрии.
    *   Метод Брезенхема сложнее для понимания и реализации (требует аккуратного вывода формул рекуррентного соотношения ошибки), но этот недостаток нивелируется его эффективностью.

4.  **Практическое применение:**
    *   В современных графических системах и драйверах видеокарт используются исключительно вариации алгоритма Брезенхема из-за их высокой скорости и возможности распараллеливания.