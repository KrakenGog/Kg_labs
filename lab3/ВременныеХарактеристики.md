## 4. Временные характеристики

Для оценки производительности реализованных алгоритмов было проведено измерение времени их выполнения. Результаты представлены в таблице ниже.

| Алгоритм | Время выполнения | Относительная скорость |
| :--- | :--- | :--- |
| **Пошаговый алгоритм** | **35 мс** | Самый медленный (100%) |
| **Алгоритм ЦДА** | **21 мс** | Быстрее пошагового в ~1.6 раза |
| **Брезенхем (Линия)** | **11 мс** | **Самый быстрый** (быстрее пошагового в >3 раза) |
| **Брезенхем (Окружность)** | **22 мс** | Эффективен для кривых второго порядка |

### Анализ результатов:

1.  **Алгоритм Брезенхема (Линия)** показал наилучший результат (**11 мс**). Это объясняется тем, что в его реализации используется только **целочисленная арифметика** (сложение и вычитание). Процессор выполняет такие операции значительно быстрее, чем операции с плавающей точкой.
2.  **Алгоритм ЦДА** занял промежуточное положение (**21 мс**). Он быстрее пошагового, так как операция умножения заменена на сложение с приращением (инкрементом), но всё еще работает с вещественными числами (`float`), что замедляет процесс.
3.  **Пошаговый алгоритм** оказался самым медленным (**35 мс**). Это связано с необходимостью выполнять «тяжелые» операции умножения и, главное, вызывать функцию округления (`round`) на каждой итерации цикла.
4.  **Алгоритм Брезенхема для окружности** (**22 мс**) показал высокую эффективность. Несмотря на то, что построение кривой второго порядка сложнее прямой, использование целочисленной логики и свойств симметрии (расчет только 1/8 части) позволило добиться времени, сопоставимого с линейным алгоритмом ЦДА.

**Вывод:** Для построения растровых примитивов наиболее предпочтителен алгоритм Брезенхема из-за его высокого быстродействия и отсутствия операций с плавающей точкой.